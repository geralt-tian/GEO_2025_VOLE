/*
This is an autogenerated file, generated using the EzPC compiler.
Then hand crafted by Wen-jie Lu
*/

#include <iostream>
#include <string>
#include "Math/math-functions.h"
#include "LinearOT/linear-ot.h"
#include "utils/emp-tool.h"
#include <chrono>

using namespace std;
using namespace sci;

int party = 0, port = 32000;
string address = "127.0.0.1";
int dim = 1024;      // 测试OT的批次数
int k = 3;           // log2(N)，N为每个OT的候选消息数（如k=3表示8选1）
int msg_bitlen = 16; // 每个消息的比特宽度

int main(int argc, char **argv)
{
    ArgMapping amap;
    amap.arg("r", party, "Role of party: ALICE = 1; BOB = 2");
    amap.arg("p", port, "Port Number");
    amap.arg("N", dim, "Number of KKOTs");
    amap.arg("ip", address, "IP Address of server (ALICE)");
    amap.parse(argc, argv);

    sci::NetIO *io = new sci::NetIO(party == 1 ? nullptr : address.c_str(), port);
    sci::OTPack<sci::NetIO> *otpack = new sci::OTPack<sci::NetIO>(io, party);

    auto start = std::chrono::high_resolution_clock::now();
    size_t comm_start = io->counter;

    int N = 1 << k;
    if (party == sci::ALICE) {
        // ALICE: 生成每个OT的N个消息
        uint64_t **messages = new uint64_t*[dim];
        for (int i = 0; i < dim; ++i) {
            messages[i] = new uint64_t[N];
            for (int j = 0; j < N; ++j) {
                messages[i][j] = (i * 100 + j) % (1ULL << msg_bitlen);
            }
        }
        std::cout << "ALICE: KKOT send start" << std::endl;
        otpack->kkot[k-1]->send(messages, dim, msg_bitlen);
        std::cout << "ALICE: KKOT send done" << std::endl;
        for (int i = 0; i < dim; ++i) delete[] messages[i];
        delete[] messages;
    } else if (party == sci::BOB) {
        // BOB: 随机选择choice
        uint8_t *choice = new uint8_t[dim];
        uint64_t *recv_buf = new uint64_t[dim];
        PRG128 prg;
        prg.random_data(choice, dim * sizeof(uint8_t));
        for (int i = 0; i < dim; ++i) choice[i] %= N;
        std::cout << "BOB: KKOT recv start" << std::endl;
        otpack->kkot[k-1]->recv(recv_buf, choice, dim, msg_bitlen);
        std::cout << "BOB: KKOT recv done" << std::endl;
        // 输出前几个结果
        for (int i = 0; i < std::min(dim, 10); ++i) {
            std::cout << "choice[" << i << "]=" << (int)choice[i]
                      << ", recv=" << recv_buf[i] << std::endl;
        }
        delete[] choice;
        delete[] recv_buf;
    }

    auto end = std::chrono::high_resolution_clock::now();
    size_t comm_end = io->counter;
    double elapsed_ms = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();

    cout << "KKOT protocol done." << endl;
    double comm_kb = (comm_end - comm_start) / 1024.0;
    cout << "Total communication: " << comm_kb << " KB" << endl;
    cout << "Elapsed time: " << elapsed_ms << " ms" << endl;

    delete otpack;
    delete io;
    return 0;
}

// int main(int argc, char **argv)
// {
//     ArgMapping amap;
//     amap.arg("r", party, "Role of party: ALICE = 1; BOB = 2");
//     amap.arg("p", port, "Port Number");
//     amap.arg("N", dim, "Number of LUT operations");
//     amap.arg("ip", address, "IP Address of server (ALICE)");
//     amap.parse(argc, argv);

//     sci::NetIO *io = new sci::NetIO(party == 1 ? nullptr : address.c_str(), port);
//     sci::OTPack<sci::NetIO> *otpack = new sci::OTPack<sci::NetIO>(io, party);
//     AuxProtocols *aux = new AuxProtocols(party, io, otpack);

//     auto start = std::chrono::high_resolution_clock::now();
//     size_t comm_start = io->counter;

//
//     otpack->kkot[bw_x - 1]->send(data, size, bw_y);

//   if (party == sci::ALICE) {
//     PRG128 prg;
//     T **data = new T *[size];
//     for (int i = 0; i < size; i++) {
//       data[i] = new T[N];
//       for (uint64_t j = 0; j < N; j++) {
//         data[i][j] = spec[i][j];
//       }
//     }
//     std::cout << "kkot A" << std::endl;
//     otpack->kkot[bw_x - 1]->send(data, size, bw_y);

//     for (int i = 0; i < size; i++) delete[] data[i];
//     delete[] data;
//   } else {  // party == sci::BOB
//     uint8_t *choice = new uint8_t[size];
//     for (int i = 0; i < size; i++) {
//       choice[i] = x[i] & mask_x;
//     }
//     std::cout << "kkot B" << std::endl;
//     otpack->kkot[bw_x - 1]->recv(y, choice, size, bw_y);

//     delete[] choice;
//   }


//     auto end = std::chrono::high_resolution_clock::now();
//     size_t comm_end = io->counter;
//     double elapsed_ms = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();

//     cout << "LUT protocol done." << endl;
//     double comm_kb = (comm_end - comm_start) / 1024.0;
//     cout << "Total communication: " << comm_kb << " KB" << endl;
//     cout << "Elapsed time: " << elapsed_ms << " ms" << endl;

//     delete aux;
//     delete otpack;
//     delete io;
//     return 0;
// }

// int main(int argc, char **argv)
// {
//     ArgMapping amap;
//     amap.arg("r", party, "Role of party: ALICE = 1; BOB = 2");
//     amap.arg("p", port, "Port Number");
//     amap.arg("N", dim, "Number of compare operations");
//     amap.arg("ip", address, "IP Address of server (ALICE)");
//     amap.parse(argc, argv);

//     sci::NetIO *io = new sci::NetIO(party == 1 ? nullptr : address.c_str(), port);
//     sci::OTPack<sci::NetIO> *otpack = new sci::OTPack<sci::NetIO>(io, party);
//     MathFunctions *math = new MathFunctions(party, io, otpack);
//     MillionaireProtocol<sci::NetIO> *mill = new MillionaireProtocol<sci::NetIO>(party, io, otpack);
//     // 生成输入
//     PRG128 prg;
//     uint64_t *x = new uint64_t[dim];
//     uint64_t *y = new uint64_t[dim];
//     prg.random_data(x, dim * sizeof(uint64_t));
//     prg.random_data(y, dim * sizeof(uint64_t));
//     for (int i = 0; i < dim; i++) {
//         x[i] &= mask_x;
//         y[i] &= mask_x;
//     }

//     // 拼接数据
//     uint64_t* data = new uint64_t[2 * dim];
//     for (int i = 0; i < dim; ++i) {
//         data[2 * i] = x[i];
//         data[2 * i + 1] = y[i];
//     }
//     uint8_t* res = new uint8_t[dim];

//     // 计时开始
//     auto start = std::chrono::high_resolution_clock::now();
//     size_t comm_start = io->counter;

//     // 调用 compare
//     mill->compare(res, data, dim, bw_x, true);

//     // 计时结束
//     auto end = std::chrono::high_resolution_clock::now();
//     size_t comm_end = io->counter;
//     double elapsed_ms = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();

//     // 可选：输出前几个比较结果
//     for (int i = 0; i < std::min(dim, 10); ++i) {
//         std::cout << "x[" << i << "]=" << x[i] << ", y[" << i << "]=" << y[i]
//                   << ", res=" << (int)res[i] << std::endl;
//     }

//     cout << "Compare done." << endl;
//     double comm_kb = (comm_end - comm_start) / 1024.0;
//     cout << "Total communication: " << comm_kb << " KB" << endl;
//     cout << "Elapsed time: " << elapsed_ms << " ms" << endl;

//     // 释放资源
//     delete[] x;
//     delete[] y;
//     delete[] data;
//     delete[] res;
//     delete math;
//     delete otpack;
//     delete io;
//     return 0;
// }

// int main(int argc, char **argv)
// {
//     ArgMapping amap;
//     amap.arg("r", party, "Role of party: ALICE = 1; BOB = 2");
//     amap.arg("p", port, "Port Number");
//     amap.arg("N", dim, "Number of tanh operations");
//     amap.arg("ip", address, "IP Address of server (ALICE)");
//     amap.parse(argc, argv);

//     sci::NetIO *io = new sci::NetIO(party == 1 ? nullptr : address.c_str(), port);
//     sci::OTPack<sci::NetIO> *otpack = new sci::OTPack<sci::NetIO>(io, party);
//     MathFunctions *math = new MathFunctions(party, io, otpack);

//   PRG128 prg;

//   uint64_t *x = new uint64_t[dim];
//   uint64_t *y = new uint64_t[dim];

//   prg.random_data(x, dim * sizeof(uint64_t));

//   for (int i = 0; i < dim; i++) {
//     x[i] &= mask_x;
//   }

//     auto start = std::chrono::high_resolution_clock::now();
//     std::cout << "Starting tanh operation" << std::endl;
//     math->tanh(dim, x, y, bw_x, bw_y, s_x, s_y);
//     std::cout << "Tanh operation completed" << std::endl;
//     long long t = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now() - start).count();

//     if (party == sci::ALICE) {
//         io->send_data(x, dim * sizeof(uint64_t));
//         io->send_data(y, dim * sizeof(uint64_t));
//     } else { // party == BOB
//         uint64_t *x0 = new uint64_t[dim];
//         uint64_t *y0 = new uint64_t[dim];
//         io->recv_data(x0, dim * sizeof(uint64_t));
//         io->recv_data(y0, dim * sizeof(uint64_t));
//         uint64_t total_err = 0;
//         uint64_t max_ULP_err = 0;
//         for (int i = 0; i < dim; i++) {
//             double dbl_x = (signed_val(x0[i] + x[i], bw_x)) / double(1LL << s_x);
//             double dbl_y = (signed_val(y0[i] + y[i], bw_y)) / double(1LL << s_y);
//             double tanh_x = tanh(dbl_x);
//             uint64_t err = computeULPErr(dbl_y, tanh_x, s_y);
//             total_err += err;
//             max_ULP_err = std::max(max_ULP_err, err);
//         }
//         cerr << "Average ULP error: " << total_err / dim << endl;
//         cerr << "Max ULP error: " << max_ULP_err << endl;
//         cerr << "Number of tests: " << dim << endl;
//         delete[] x0;
//         delete[] y0;
//     }

//     cout << "Tanh Time\t" << t / (1000.0) << " ms" << endl;

//     delete[] x;
//     delete[] y;
//     delete math;
//     delete otpack;
//     delete io;
//     return 0;
// }
